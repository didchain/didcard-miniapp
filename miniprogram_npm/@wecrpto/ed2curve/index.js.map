{"version":3,"sources":["ed2curve.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\r\n * ed2curve: convert Ed25519 signing key pair into Curve25519\r\n * key pair suitable for Diffie-Hellman key exchange.\r\n *\r\n * Written by Dmitry Chestnykh in 2014. Public domain.\r\n */\r\n/* jshint newcap: false */\r\n(function(root, f) {\r\n  \r\n  if (typeof module !== 'undefined' && module.exports) module.exports = f(require('@wecrpto/nacl'));\r\n  else root.ed2curve = f(root.nacl);\r\n}(this, function(nacl) {\r\n  \r\n  if (!nacl) throw new Error('tweetnacl not loaded');\r\n\r\n  // -- Operations copied from TweetNaCl.js. --\r\n\r\n  var gf = function(init) {\r\n    var i, r = new Float64Array(16);\r\n    if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\r\n    return r;\r\n  };\r\n\r\n  var gf0 = gf(),\r\n      gf1 = gf([1]),\r\n      D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\r\n      I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\r\n\r\n  function car25519(o) {\r\n    var c;\r\n    var i;\r\n    for (i = 0; i < 16; i++) {\r\n      o[i] += 65536;\r\n      c = Math.floor(o[i] / 65536);\r\n      o[(i+1)*(i<15?1:0)] += c - 1 + 37 * (c-1) * (i===15?1:0);\r\n      o[i] -= (c * 65536);\r\n    }\r\n  }\r\n\r\n  function sel25519(p, q, b) {\r\n    var t, c = ~(b-1);\r\n    for (var i = 0; i < 16; i++) {\r\n      t = c & (p[i] ^ q[i]);\r\n      p[i] ^= t;\r\n      q[i] ^= t;\r\n    }\r\n  }\r\n\r\n  function unpack25519(o, n) {\r\n    var i;\r\n    for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\r\n    o[15] &= 0x7fff;\r\n  }\r\n\r\n  // addition\r\n  function A(o, a, b) {\r\n    var i;\r\n    for (i = 0; i < 16; i++) o[i] = (a[i] + b[i])|0;\r\n  }\r\n\r\n  // subtraction\r\n  function Z(o, a, b) {\r\n    var i;\r\n    for (i = 0; i < 16; i++) o[i] = (a[i] - b[i])|0;\r\n  }\r\n\r\n  // multiplication\r\n  function M(o, a, b) {\r\n    var i, j, t = new Float64Array(31);\r\n    for (i = 0; i < 31; i++) t[i] = 0;\r\n    for (i = 0; i < 16; i++) {\r\n      for (j = 0; j < 16; j++) {\r\n        t[i+j] += a[i] * b[j];\r\n      }\r\n    }\r\n    for (i = 0; i < 15; i++) {\r\n      t[i] += 38 * t[i+16];\r\n    }\r\n    for (i = 0; i < 16; i++) o[i] = t[i];\r\n    car25519(o);\r\n    car25519(o);\r\n  }\r\n\r\n  // squaring\r\n  function S(o, a) {\r\n    M(o, a, a);\r\n  }\r\n\r\n  // inversion\r\n  function inv25519(o, i) {\r\n    var c = gf();\r\n    var a;\r\n    for (a = 0; a < 16; a++) c[a] = i[a];\r\n    for (a = 253; a >= 0; a--) {\r\n      S(c, c);\r\n      if(a !== 2 && a !== 4) M(c, c, i);\r\n    }\r\n    for (a = 0; a < 16; a++) o[a] = c[a];\r\n  }\r\n\r\n  function pack25519(o, n) {\r\n    var i, j, b;\r\n    var m = gf(), t = gf();\r\n    for (i = 0; i < 16; i++) t[i] = n[i];\r\n    car25519(t);\r\n    car25519(t);\r\n    car25519(t);\r\n    for (j = 0; j < 2; j++) {\r\n      m[0] = t[0] - 0xffed;\r\n      for (i = 1; i < 15; i++) {\r\n        m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\r\n        m[i-1] &= 0xffff;\r\n      }\r\n      m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\r\n      b = (m[15]>>16) & 1;\r\n      m[14] &= 0xffff;\r\n      sel25519(t, m, 1-b);\r\n    }\r\n    for (i = 0; i < 16; i++) {\r\n      o[2*i] = t[i] & 0xff;\r\n      o[2*i+1] = t[i] >> 8;\r\n    }\r\n  }\r\n\r\n  function par25519(a) {\r\n    var d = new Uint8Array(32);\r\n    pack25519(d, a);\r\n    return d[0] & 1;\r\n  }\r\n\r\n  function vn(x, xi, y, yi, n) {\r\n    var i, d = 0;\r\n    for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];\r\n    return (1 & ((d - 1) >>> 8)) - 1;\r\n  }\r\n\r\n  function crypto_verify_32(x, xi, y, yi) {\r\n    return vn(x, xi, y, yi, 32);\r\n  }\r\n\r\n  function neq25519(a, b) {\r\n    var c = new Uint8Array(32), d = new Uint8Array(32);\r\n    pack25519(c, a);\r\n    pack25519(d, b);\r\n    return crypto_verify_32(c, 0, d, 0);\r\n  }\r\n\r\n  function pow2523(o, i) {\r\n    var c = gf();\r\n    var a;\r\n    for (a = 0; a < 16; a++) c[a] = i[a];\r\n    for (a = 250; a >= 0; a--) {\r\n      S(c, c);\r\n      if (a !== 1) M(c, c, i);\r\n    }\r\n    for (a = 0; a < 16; a++) o[a] = c[a];\r\n  }\r\n\r\n  function set25519(r, a) {\r\n    var i;\r\n    for (i = 0; i < 16; i++) r[i] = a[i] | 0;\r\n  }\r\n\r\n  function unpackneg(r, p) {\r\n    var t = gf(), chk = gf(), num = gf(),\r\n      den = gf(), den2 = gf(), den4 = gf(),\r\n      den6 = gf();\r\n\r\n    set25519(r[2], gf1);\r\n    unpack25519(r[1], p);\r\n    S(num, r[1]);\r\n    M(den, num, D);\r\n    Z(num, num, r[2]);\r\n    A(den, r[2], den);\r\n\r\n    S(den2, den);\r\n    S(den4, den2);\r\n    M(den6, den4, den2);\r\n    M(t, den6, num);\r\n    M(t, t, den);\r\n\r\n    pow2523(t, t);\r\n    M(t, t, num);\r\n    M(t, t, den);\r\n    M(t, t, den);\r\n    M(r[0], t, den);\r\n\r\n    S(chk, r[0]);\r\n    M(chk, chk, den);\r\n    if (neq25519(chk, num)) M(r[0], r[0], I);\r\n\r\n    S(chk, r[0]);\r\n    M(chk, chk, den);\r\n    if (neq25519(chk, num)) return -1;\r\n\r\n    if (par25519(r[0]) === (p[31] >> 7)) Z(r[0], gf0, r[0]);\r\n\r\n    M(r[3], r[0], r[1]);\r\n    return 0;\r\n  }\r\n\r\n  // ----\r\n\r\n  // Converts Ed25519 public key to Curve25519 public key.\r\n  // montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p\r\n  function convertPublicKey(pk) {\r\n    var z = new Uint8Array(32),\r\n      q = [gf(), gf(), gf(), gf()],\r\n      a = gf(), b = gf();\r\n\r\n    if (unpackneg(q, pk)) return null; // reject invalid key\r\n\r\n    var y = q[1];\r\n\r\n    A(a, gf1, y);\r\n    Z(b, gf1, y);\r\n    inv25519(b, b);\r\n    M(a, a, b);\r\n\r\n    pack25519(z, a);\r\n    return z;\r\n  }\r\n\r\n  // Converts Ed25519 secret key to Curve25519 secret key.\r\n  function convertSecretKey(sk) {\r\n    var d = new Uint8Array(64), o = new Uint8Array(32), i;\r\n    nacl.lowlevel.crypto_hash(d, sk, 32);\r\n    d[0] &= 248;\r\n    d[31] &= 127;\r\n    d[31] |= 64;\r\n    for (i = 0; i < 32; i++) o[i] = d[i];\r\n    for (i = 0; i < 64; i++) d[i] = 0;\r\n    return o;\r\n  }\r\n\r\n  function convertKeyPair(edKeyPair) {\r\n    var publicKey = convertPublicKey(edKeyPair.publicKey);\r\n    if (!publicKey) return null;\r\n    return {\r\n      publicKey: publicKey,\r\n      secretKey: convertSecretKey(edKeyPair.secretKey)\r\n    };\r\n  }\r\n\r\n  return {\r\n    convertPublicKey: convertPublicKey,\r\n    convertSecretKey: convertSecretKey,\r\n    convertKeyPair: convertKeyPair\r\n  };\r\n\r\n}));\r\n"]}